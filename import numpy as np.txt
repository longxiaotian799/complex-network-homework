import numpy as np
import matplotlib.pyplot as plt

# 生成N=100，连边概率p=0.05的随机网络的邻接矩阵
N = 100
p = 0.05
adj_mat = np.random.rand(N, N) < p
np.fill_diagonal(adj_mat, False)
adj_mat = np.triu(adj_mat)
adj_mat += adj_mat.T

# 计算最大连通子图的规模
visited = np.zeros(N, dtype=bool)
largest_cc_size = 0
for i in range(N):
    if not visited[i]:
        queue = [i]
        visited[i] = True
        cc_size = 1
        while len(queue) > 0:
            node = queue.pop(0)
            neighbors = np.where(adj_mat[node])[0]
            for neighbor in neighbors:
                if not visited[neighbor]:
                    visited[neighbor] = True
                    queue.append(neighbor)
                    cc_size += 1
        if cc_size > largest_cc_size:
            largest_cc_size = cc_size

print(f"最大连通子图的规模为: {largest_cc_size}")

# 求最大连通子图的平均路径长度和平均聚类系数
subgraph_indices = np.where(visited)[0]
subgraph_adj_mat = adj_mat[subgraph_indices][:, subgraph_indices]
dist_mat = np.zeros_like(subgraph_adj_mat)
dist_mat[subgraph_adj_mat] = 1
for k in range(largest_cc_size):
    for i in range(largest_cc_size):
        for j in range(largest_cc_size):
            if dist_mat[i, k] and dist_mat[k, j]:
                if dist_mat[i, j] == 0:
                    dist_mat[i, j] = dist_mat[i, k] + dist_mat[k, j]
                else:
                    dist_mat[i, j] = min(dist_mat[i, j], dist_mat[i, k] + dist_mat[k, j])
avg_path_length = np.sum(dist_mat) / (largest_cc_size * (largest_cc_size - 1))
clustering_coef = []
for i in range(largest_cc_size):
    neighbors = np.where(subgraph_adj_mat[i])[0]
    num_neighbors = len(neighbors)
    if num_neighbors > 1:
        edges = 0
        for j in range(num_neighbors):
            for k in range(j+1, num_neighbors):
                edges += subgraph_adj_mat[neighbors[j], neighbors[k]]
        clustering_coef.append(2 * edges / (num_neighbors * (num_neighbors - 1)))
avg_clustering_coef = np.mean(clustering_coef)

print(f"最大连通子图的平均路径长度为: {avg_path_length}")
print(f"最大连通子图的平均聚类系数为: {avg_clustering_coef}")

# 统计度分布
degrees = np.sum(adj_mat, axis=0)
max_degree = int(np.max(degrees))
degree_distribution = np.zeros(max_degree+1)
for degree in degrees:
    degree_distribution[int(degree)] += 1
degree_distribution /= N

# 输出统计结果
print("度分布: ")
for i, p in enumerate(degree_distribution):
    print(f"度为 {i} 的节点比例为: {p:.4f}")